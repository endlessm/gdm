Make all local displays "transient".
By default, they are not reaped at the end of the session and go back to 
the login prompt.

Index: gdm3-3.14.1/daemon/Makefile.am
===================================================================
--- gdm3-3.14.1.orig/daemon/Makefile.am	2014-11-09 18:30:31.474923397 +0100
+++ gdm3-3.14.1/daemon/Makefile.am	2014-11-09 18:30:31.470923456 +0100
@@ -35,7 +35,6 @@ AM_CPPFLAGS = \
 BUILT_SOURCES =					\
 	gdm-display-glue.h			\
 	gdm-manager-glue.h			\
-	gdm-static-display-glue.h		\
 	gdm-transient-display-glue.h		\
 	gdm-local-display-factory-glue.h	\
 	gdm-session-glue.h			\
@@ -63,13 +62,6 @@ gdm-transient-display-glue.c gdm-transie
 		--generate-c-code=gdm-transient-display-glue		\
 		$(srcdir)/gdm-transient-display.xml
 
-gdm-static-display-glue.c gdm-static-display-glue.h: gdm-static-display.xml Makefile.am
-	$(AM_V_GEN)gdbus-codegen 					\
-		--c-namespace=GdmDBus					\
-		--interface-prefix=org.gnome.DisplayManager		\
-		--generate-c-code=gdm-static-display-glue		\
-		$(srcdir)/gdm-static-display.xml
-
 gdm-local-display-factory-glue.c gdm-local-display-factory-glue.h : gdm-local-display-factory.xml Makefile.am
 	$(AM_V_GEN)gdbus-codegen 					\
 		--c-namespace=GdmDBus					\
@@ -186,8 +178,6 @@ gdm_SOURCES = 			\
 	gdm-local-display-factory.h	\
 	gdm-display.c			\
 	gdm-display.h			\
-	gdm-static-display.c		\
-	gdm-static-display.h		\
 	gdm-transient-display.c		\
 	gdm-transient-display.h		\
 	gdm-launch-environment.c	\
@@ -223,8 +213,6 @@ nodist_gdm_SOURCES = 			\
 	gdm-manager-glue.c			\
 	gdm-transient-display-glue.h		\
 	gdm-transient-display-glue.c		\
-	gdm-static-display-glue.h		\
-	gdm-static-display-glue.c		\
 	gdm-session-glue.h			\
 	gdm-session-glue.c			\
 	gdm-session-worker-glue.c		\
@@ -281,7 +269,6 @@ CLEANFILES =					\
 	gdm-session-glue.c			\
 	gdm-session-worker-glue.c		\
 	gdm-session-enum-types.c		\
-	gdm-static-display-glue.c		\
 	gdm-transient-display-glue.c		\
 	$(BUILT_SOURCES)			\
 	$(NULL)
@@ -291,7 +278,6 @@ EXTRA_DIST = 				\
 	gdm-session-worker.xml		\
 	gdm-session.xml			\
 	gdm-display.xml			\
-	gdm-static-display.xml		\
 	gdm-transient-display.xml	\
 	gdm-local-display-factory.xml	\
 	gdm-session-enum-types.c.in	\
Index: gdm3-3.14.1/daemon/gdm-local-display-factory.c
===================================================================
--- gdm3-3.14.1.orig/daemon/gdm-local-display-factory.c	2014-11-09 18:30:31.474923397 +0100
+++ gdm3-3.14.1/daemon/gdm-local-display-factory.c	2014-11-09 18:30:31.474923397 +0100
@@ -35,7 +35,6 @@
 #include "gdm-local-display-factory-glue.h"
 
 #include "gdm-display-store.h"
-#include "gdm-static-display.h"
 #include "gdm-transient-display.h"
 
 #define GDM_LOCAL_DISPLAY_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_LOCAL_DISPLAY_FACTORY, GdmLocalDisplayFactoryPrivate))
@@ -290,8 +289,8 @@ on_display_status_changed (GdmDisplay
                 g_hash_table_remove (factory->priv->displays, GUINT_TO_POINTER (num));
                 gdm_display_store_remove (store, display);
 
-                /* Create a new equivalent display if it was static */
-                if (GDM_IS_STATIC_DISPLAY (display)) {
+                /* Create a new equivalent display if needed */
+                if (gdm_display_get_switch_on_finish (display)) {
                         /* reset num failures */
                         factory->priv->num_failures = 0;
 
@@ -303,8 +302,8 @@ on_display_status_changed (GdmDisplay
                    so that it doesn't get reused */
                 gdm_display_store_remove (store, display);
 
-                /* Create a new equivalent display if it was static */
-                if (GDM_IS_STATIC_DISPLAY (display)) {
+                /* Create a new equivalent display if needed */
+                if (gdm_display_get_switch_on_finish (display)) {
 
                         factory->priv->num_failures++;
 
@@ -370,7 +369,7 @@ create_display (GdmLocalDisplayFactory *
 
         num = take_next_display_number (factory);
 
-        display = gdm_static_display_new (num);
+        display = gdm_transient_display_new (num);
 
         g_object_set (display, "seat-id", seat_id, NULL);
         g_object_set (display, "is-initial", initial, NULL);
Index: gdm3-3.14.1/daemon/gdm-transient-display.c
===================================================================
--- gdm3-3.14.1.orig/daemon/gdm-transient-display.c	2014-11-09 18:30:31.474923397 +0100
+++ gdm3-3.14.1/daemon/gdm-transient-display.c	2014-11-09 18:31:03.034454271 +0100
@@ -94,9 +94,22 @@ gdm_transient_display_manage (GdmDisplay
 static gboolean
 gdm_transient_display_finish (GdmDisplay *display)
 {
+        int status;
+
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
-        GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->finish (display);
+        if (gdm_display_get_switch_on_finish (display)) {
+                /* restart display */
+                gdm_display_unmanage (display);
+
+                status = gdm_display_get_status (display);
+                if (status != GDM_DISPLAY_FAILED) {
+                        gdm_display_manage (display);
+                }
+        } else {
+                /* Call parent's finish to be put in the FINISHED state */
+                GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->finish (display);
+        }
 
         return TRUE;
 }
@@ -117,9 +130,16 @@ gdm_transient_display_get_timed_login_de
                                                char      **usernamep,
                                                int        *delayp)
 {
-        *enabledp = FALSE;
-        *usernamep = g_strdup ("");
-        *delayp = 0;
+        gboolean is_initial = FALSE;
+        gdm_display_is_initial (display, &is_initial, NULL);
+
+        if (is_initial) {
+                GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->get_timed_login_details (display, enabledp, usernamep, delayp);
+        } else {
+                *enabledp = FALSE;
+                *usernamep = g_strdup ("");
+                *delayp = 0;
+        }
 }
 
 static GObject *
